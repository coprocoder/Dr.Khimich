"use strict";(self.webpackChunkdr_khimich=self.webpackChunkdr_khimich||[]).push([[20],{1588:(t,e,n)=>{var o=n(4836);e.Z=void 0;var s=o(n(5649)),r=n(184),c=(0,s.default)((0,r.jsx)("path",{d:"M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"}),"LocationOn");e.Z=c},2716:(t,e,n)=>{var o=n(4836);e.Z=void 0;var s=o(n(5649)),r=n(184),c=(0,s.default)((0,r.jsx)("path",{d:"M6.62 10.79c1.44 2.83 3.76 5.14 6.59 6.59l2.2-2.2c.27-.27.67-.36 1.02-.24 1.12.37 2.33.57 3.57.57.55 0 1 .45 1 1V20c0 .55-.45 1-1 1-9.39 0-17-7.61-17-17 0-.55.45-1 1-1h3.5c.55 0 1 .45 1 1 0 1.25.2 2.45.57 3.57.11.35.03.74-.25 1.02l-2.2 2.2z"}),"Phone");e.Z=c},2686:(t,e,n)=>{var o=n(4836);e.Z=void 0;var s=o(n(5649)),r=n(184),c=(0,s.default)((0,r.jsx)("path",{d:"M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm4.2 14.2L11 13V7h1.5v5.2l4.5 2.7-.8 1.3z"}),"WatchLater");e.Z=c},6329:(t,e,n)=>{n.d(e,{D5:()=>x,Yy:()=>f,ah:()=>z});var o=n(2791);function s(){return s=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(t[o]=n[o])}return t},s.apply(this,arguments)}const r=(t,e)=>{const n={};for(const o in t)-1===e.indexOf(o)&&(n[o]=t[o]);return n},c=o.createContext(null),a=o.createContext(null),i=t=>e=>o.createElement(a.Consumer,null,(n=>o.createElement(t,s({parent:n},e)))),l=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];const[e,n]=(0,o.useState)(!1),s=(0,o.useRef)(t),r=(()=>{const t=(0,o.useContext)(c);if(null===t)throw new Error("Couldn't find Yandex.Maps API in the context. Make sure that hook useYMaps is inside <YMaps /> provider");return t})(),a=r.getApi();return(0,o.useEffect)((()=>{r.load().then((()=>Promise.all(s.current.map(r.loadModule)))).then((()=>n(!0)))}),[]),e&&a?a:null},p=()=>{},u=["onLoad","onError","modules","apiLoader"];function d(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];return c=>{const{width:a,height:i,modules:d=[],onLoad:m=p}=c,h=l(n.concat(d)),f=!e||!!h,y=r(c,u);return(0,o.useEffect)((()=>h?m(h):void 0),[h]),f?o.createElement(t,s({ymaps:h},y)):o.createElement("div",{style:{width:a,height:i}})}}const m="undefined"!=typeof window,h={lang:"ru_RU",load:"",ns:"",mode:"release"},f=t=>{const{version:e="2.1",enterprise:n=!1,query:s={lang:"ru_RU",load:"",ns:""},preload:r=!1,children:a}=t,i=(0,o.useRef)((t=>{const{query:e=h}=t,n=Date.now().toString(32),o=e.ns||"",s="__yandex-maps-api-onload__$$"+n,r="__yandex-maps-api-onerror__$$"+n,c=m?window:{},a={};let i;const l=()=>o?c[o]:i,p=()=>{delete c[s],delete c[r]};return{load:()=>{if(l())return Promise.resolve(i);if(a[o])return a[o];const n={onload:s,onerror:r,...h,...e},u=Object.keys(n).map((t=>"".concat(t,"=").concat(n[t]))).join("&"),d=["https://".concat(t.enterprise?"enterprise.":"","api-maps.yandex.ru"),t.version,"?"+u].join("/");return a[o]=new Promise(((t,e)=>{c[s]=e=>{p(),e.ready((()=>{i=e,t(e)}))},c[r]=t=>{p(),e(t)},(t=>new Promise(((e,n)=>{const o=document.createElement("script");o.type="text/javascript",o.onload=e,o.onerror=n,o.src=t,o.async=!0,document.head.appendChild(o)})))(d).catch(c[r])})),a[o]},getApi:l,loadModule:t=>new Promise(((e,n)=>{i.modules.require(t).done((n=>{n.forEach((e=>{!function(t,e,n){let o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s="string"==typeof e?e.split("."):e.slice();let r,c=t;for(;s.length>1;)r=s.shift(),c[r]||(c[r]={}),c=c[r];const a=s[0];c[a]=!0===o&&c[a]||n}(i,t,e,!0)})),e(i)}),n)}))}})({version:e,enterprise:n,query:s,preload:r}));return(0,o.useEffect)((()=>{r&&i.current.load()}),[i.current]),o.createElement(c.Provider,{value:i.current},a)},y=/^on(?=[A-Z])/;function v(t){return Object.keys(t).reduce(((e,n)=>{if(y.test(n)){const o=n.replace(y,"").toLowerCase();e._events[o]=t[n]}else e[n]=t[n];return e}),{_events:{}})}function b(t,e,n){"function"==typeof n&&t.events.add(e,n)}function j(t,e,n){"function"==typeof n&&t.events.remove(e,n)}function O(t,e,n){Object.keys(Object.assign({},e,n)).forEach((o=>{e[o]!==n[o]&&(j(t,o,e[o]),b(t,o,n[o]))}))}const g=t=>"default"+t.charAt(0).toUpperCase()+t.slice(1);function E(t,e){return void 0!==t[e]||void 0===t[g(e)]}function _(t,e,n){return(E(t,e)?t[e]:t[g(e)])||n}function C(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(t!==e){if(t&&("current"in t?t.current=null:"function"==typeof t&&t(null)),!e)return;"current"in e?e.current=n:"function"==typeof e&&e(n)}}function R(t){const{width:e,height:n,style:o,className:s}=t;return void 0!==o||void 0!==s?Object.assign({},o&&{style:o},s&&{className:s}):{style:{width:e,height:n}}}class w extends o.Component{constructor(t){super(t),this.state={error:null,errorInfo:null}}componentDidCatch(t,e){const{onError:n=(()=>{})}=this.props;n(t),this.setState({error:t,errorInfo:e})}render(){return this.state.error?null:this.props.children}}const P=t=>e=>{let{onError:n,...s}=e;return o.createElement(w,{onError:n},o.createElement(t,s))};class k extends o.Component{constructor(){super(),this.instance=null,this.state={instance:null},this._parentElement=null,this._getRef=t=>{this._parentElement=t}}componentDidMount(){this.instance=k.mountObject(this._parentElement,this.props.ymaps.Map,this.props),this.setState({instance:this.instance})}componentDidUpdate(t){null!==this.instance&&k.updateObject(this.instance,t,this.props)}componentWillUnmount(){k.unmountObject(this.instance,this.props)}render(){const t=R(this.props),e=v(this.props),n=r(e,["_events","state","defaultState","options","defaultOptions","instanceRef","ymaps","children","width","height","style","className"]);return o.createElement(a.Provider,{value:this.state.instance},o.createElement("div",s({ref:this._getRef},t,n),this.props.children))}static mountObject(t,e,n){const{instanceRef:o,_events:s}=v(n),r=new e(t,_(n,"state"),_(n,"options"));return Object.keys(s).forEach((t=>b(r,t,s[t]))),C(null,o,r),r}static updateObject(t,e,n){const{_events:o,instanceRef:s}=v(n),{_events:r,instanceRef:c}=v(e);if(E(n,"state")){const o=_(e,"state",{}),s=_(n,"state",{});o.type!==s.type&&t.setType(s.type),o.behaviors!==s.behaviors&&(o.behaviors&&t.behaviors.disable(o.behaviors),s.behaviors&&t.behaviors.enable(s.behaviors)),s.zoom&&o.zoom!==s.zoom&&t.setZoom(s.zoom),s.center&&o.center!==s.center&&t.setCenter(s.center),s.bounds&&o.bounds!==s.bounds&&t.setBounds(s.bounds)}if(E(n,"options")){const o=_(e,"options"),s=_(n,"options",{});o!==s&&t.options.set(s)}_(e,"width")===_(n,"width")&&_(e,"height")===_(n,"height")||t.container.fitToViewport(),O(t,r,o),C(c,s,t)}static unmountObject(t,e){const{instanceRef:n,_events:o}=v(e);null!==t&&(Object.keys(o).forEach((e=>j(t,e,o[e]))),t.destroy(),C(n))}}const x=P(d(k,!0,["Map"]));x.defaultProps={width:320,height:240};class M extends o.Component{constructor(){super(),this.state={instance:null},this._parentElement=null,this._getRef=t=>{this._parentElement=t}}componentDidMount(){this._mounted=!0,this.props.ymaps.panorama.isSupported()&&M.mountObject(this._parentElement,this.props.ymaps.panorama,this.props).then((t=>this._mounted&&this.setState({instance:t})))}componentDidUpdate(t){null!==this.state.instance&&M.updateObject(this.state.instance,t,this.props)}componentWillUnmount(){this._mounted=!1,M.unmountObject(this.state.instance,this.props)}render(){const t=R(this.props);return o.createElement("div",s({ref:this._getRef},t))}static mountObject(t,e,n){const{instanceRef:o,_events:s}=v(n),r=_(n,"point"),c=_(n,"locateOptions"),a=_(n,"options");return new Promise(((n,i)=>{e.locate(r,c).done((r=>{if(r.length>0){const c=new e.Player(t,r[0],a);C(null,o,c),Object.keys(s).forEach((t=>b(c,t,s[t]))),n(c)}}),i)}))}static updateObject(t,e,n){const{_events:o,instanceRef:s}=v(n),{_events:r,instanceRef:c}=v(e);if(E(n,"options")){const o=_(e,"options"),s=_(n,"options");o!==s&&t.options.set(s)}if(E(n,"point")){const o=_(n,"point"),s=_(e,"point"),r=_(n,"locateOptions");o!==s&&t.moveTo(o,r)}O(t,r,o),C(c,s,t)}static unmountObject(t,e){const{instanceRef:n,_events:o}=v(e);null!==t&&(Object.keys(o).forEach((e=>j(t,e,o[e]))),C(n))}}P(d(M,!0,["panorama.isSupported","panorama.locate","panorama.createPlayer","panorama.Player"])).defaultProps={width:320,height:240};class S extends o.Component{constructor(){super(),this.state={instance:null},this.instance=null}componentDidMount(){const t=S.mountControl(this.props.ymaps.control[this.props.name],this.props);this.instance=t,this.setState({instance:t})}componentDidUpdate(t){null!==this.instance&&S.updateControl(this.instance,t,this.props)}componentWillUnmount(){S.unmountControl(this.instance,this.props)}render(){return o.createElement(a.Provider,{value:this.state.instance},this.props.children)}static mountControl(t,e){const{instanceRef:n,parent:o,lazy:s,_events:r}=v(e),c=new t({data:_(e,"data"),options:_(e,"options"),state:_(e,"state"),mapTypes:_(e,"mapTypes"),lazy:s});if(Object.keys(r).forEach((t=>b(c,t,r[t]))),o&&o.controls&&"function"==typeof o.controls.add)o.controls.add(c);else{if(!o||!o.add||"function"!=typeof o.add)throw new Error("No parent found to mount ".concat(e.name));o.add(c)}return C(null,n,c),c}static updateControl(t,e,n){const{_events:o,instanceRef:s}=v(n),{_events:r,instanceRef:c}=v(e);if(E(n,"options")){const o=_(e,"options"),s=_(n,"options");o!==s&&t.options.set(s)}if(E(n,"data")){const o=_(e,"data"),s=_(n,"data");o!==s&&t.data.set(s)}if(E(n,"state")){const o=_(e,"state"),s=_(n,"state");o!==s&&t.state.set(s)}if(E(n,"mapTypes")){const o=_(e,"mapTypes"),s=_(n,"mapTypes");o!==s&&(t.removeAllMapTypes(),s.forEach((e=>t.addMapType(e))))}O(t,r,o),C(c,s,t)}static unmountControl(t,e){const{instanceRef:n,parent:o,_events:s}=v(e);null!==t&&(Object.keys(s).forEach((e=>j(t,e,s[e]))),o.controls&&"function"==typeof o.controls.remove?o.controls.remove(t):o.remove&&"function"==typeof o.remove&&o.remove(t),C(n))}}P(i(d((t=>o.createElement(S,s({},t,{name:"Button"}))),!0,["control.Button"]))),P(i(d((t=>o.createElement(S,s({},t,{name:"FullscreenControl"}))),!0,["control.FullscreenControl"]))),P(i(d((t=>o.createElement(S,s({},t,{name:"GeolocationControl"}))),!0,["control.GeolocationControl"]))),P(i(d((t=>o.createElement(S,s({},t,{name:"ListBox"}))),!0,["control.ListBox"]))),P(i(d((t=>o.createElement(S,s({},t,{name:"ListBoxItem"}))),!0,["control.ListBoxItem"]))),P(i(d((t=>o.createElement(S,s({},t,{name:"RouteButton"}))),!0,["control.RouteButton"]))),P(i(d((t=>o.createElement(S,s({},t,{name:"RouteEditor"}))),!0,["control.RouteEditor"]))),P(i(d((t=>o.createElement(S,s({},t,{name:"RoutePanel"}))),!0,["control.RoutePanel"]))),P(i(d((t=>o.createElement(S,s({},t,{name:"RulerControl"}))),!0,["control.RulerControl"]))),P(i(d((t=>o.createElement(S,s({},t,{name:"SearchControl"}))),!0,["control.SearchControl"]))),P(i(d((t=>o.createElement(S,s({},t,{name:"TrafficControl"}))),!0,["control.TrafficControl"]))),P(i(d((t=>o.createElement(S,s({},t,{name:"TypeSelector"}))),!0,["control.TypeSelector"]))),P(i(d((t=>o.createElement(S,s({},t,{name:"ZoomControl"}))),!0,["control.ZoomControl"])));class D extends o.Component{constructor(){super(),this.state={instance:null},this.instance=null}componentDidMount(){const t=D.mountObject(this.props.ymaps.Clusterer,this.props);this.instance=t,this.setState({instance:t})}componentDidUpdate(t){null!==this.state.instance&&D.updateObject(this.instance,t,this.props)}componentWillUnmount(){D.unmountObject(this.instance,this.props)}render(){return o.createElement(a.Provider,{value:this.state.instance},this.props.children)}static mountObject(t,e){const{instanceRef:n,parent:o,_events:s}=v(e),r=new t(_(e,"options"));if(Object.keys(s).forEach((t=>b(r,t,s[t]))),o.geoObjects&&"function"==typeof o.geoObjects.add)o.geoObjects.add(r);else{if(!o.add||"function"!=typeof o.add)throw new Error("No parent found to mount Clusterer");o.add(r)}return C(null,n,r),r}static updateObject(t,e,n){const{_events:o,instanceRef:s}=v(n),{_events:r,instanceRef:c}=v(e);if(E(n,"options")){const o=_(e,"options"),s=_(n,"options");o!==s&&t.options.set(s)}O(t,r,o),C(c,s,t)}static unmountObject(t,e){const{instanceRef:n,parent:o,_events:s}=v(e);null!==t&&(Object.keys(s).forEach((e=>j(t,e,s[e]))),o.geoObjects&&"function"==typeof o.geoObjects.remove?o.geoObjects.remove(t):o.remove&&"function"==typeof o.remove&&o.remove(t),C(n))}}P(i(d(D,!0,["Clusterer"])));class U extends o.Component{constructor(){super(),this.state={instance:null}}componentDidMount(){const t=U.mountObject(this.props.ymaps.ObjectManager,this.props);this.instance=t,this.setState({instance:t})}componentDidUpdate(t){null!==this.instance&&U.updateObject(this.instance,t,this.props)}componentWillUnmount(){U.unmountObject(this.instance,this.props)}render(){return null}static mountObject(t,e){const{instanceRef:n,parent:o,_events:s}=v(e),r=_(e,"options",{}),c=_(e,"features",{}),a=_(e,"filter",null),i=_(e,"objects",{}),l=_(e,"clusters",{}),p=new t(r);if(p.add(c||[]),p.setFilter(a),p.objects.options.set(i),p.clusters.options.set(l),Object.keys(s).forEach((t=>b(p,t,s[t]))),o.geoObjects&&"function"==typeof o.geoObjects.add)o.geoObjects.add(p);else{if(!o.add||"function"!=typeof o.add)throw new Error("No parent found to mount ObjectManager");o.add(p)}return C(null,n,p),p}static updateObject(t,e,n){const{_events:o,instanceRef:s}=v(n),{_events:r,instanceRef:c}=v(e);if(E(n,"options")){const o=_(e,"options"),s=_(n,"options");o!==s&&t.options.set(s)}if(E(n,"objects")){const o=_(e,"objects"),s=_(n,"objects");o!==s&&t.objects.options.set(s)}if(E(n,"clusters")){const o=_(e,"clusters"),s=_(n,"clusters");o!==s&&t.clusters.options.set(s)}if(E(n,"filter")){const o=_(e,"filter"),s=_(n,"filter");o!==s&&t.setFilter(s)}if(E(n,"features")){const o=_(e,"features"),s=_(n,"features");o!==s&&(t.remove(o),t.add(s))}O(t,r,o),C(c,s,t)}static unmountObject(t,e){const{instanceRef:n,parent:o,_events:s}=v(e);null!==t&&(Object.keys(s).forEach((e=>j(t,e,s[e]))),o.geoObjects&&"function"==typeof o.geoObjects.remove?o.geoObjects.remove(t):o.remove&&"function"==typeof o.remove&&o.remove(t),C(n))}}P(i(d(U,!0,["ObjectManager"])));class T extends o.Component{constructor(){super(),this.state={instance:null},this.instance=null}componentDidMount(){const{name:t,ymaps:e,dangerZone:n}=this.props,o=T.mountObject(n&&"function"==typeof n.modifyConstructor?n.modifyConstructor(e[t]):e[t],this.props);this.instance=o,this.setState({instance:o})}componentDidUpdate(t){null!==this.instance&&T.updateObject(this.instance,t,this.props)}componentWillUnmount(){T.unmountObject(this.instance,this.props)}render(){return null}static mountObject(t,e){const{instanceRef:n,parent:o,_events:s}=v(e),r=new t(_(e,"geometry"),_(e,"properties"),_(e,"options"));if(Object.keys(s).forEach((t=>b(r,t,s[t]))),o&&o.geoObjects&&"function"==typeof o.geoObjects.add)o.geoObjects.add(r);else{if(!o||!o.add||"function"!=typeof o.add)throw new Error("No parent found to mount ".concat(e.name));o.add(r)}return C(null,n,r),r}static updateObject(t,e,n){const{_events:o,instanceRef:s}=v(n),{_events:r,instanceRef:c}=v(e);if(E(n,"geometry")){const o=_(e,"geometry",{}),s=_(n,"geometry",{});Array.isArray(s)&&s!==o?Array.isArray(s[0])&&"number"==typeof s[1]?(t.geometry.setCoordinates(s[0]),t.geometry.setRadius(s[1])):t.geometry.setCoordinates(s):"object"==typeof s&&(s.coordinates!==o.coordinates&&t.geometry.setCoordinates(s.coordinates),s.radius!==o.radius&&t.geometry.setRadius(s.radius))}if(E(n,"properties")){const o=_(e,"properties"),s=_(n,"properties");o!==s&&t.properties.set(s)}if(E(n,"options")){const o=_(e,"options"),s=_(n,"options");o!==s&&t.options.set(s)}O(t,r,o),C(c,s,t)}static unmountObject(t,e){const{instanceRef:n,parent:o,_events:s}=v(e);null!==t&&(Object.keys(s).forEach((e=>j(t,e,s[e]))),o.geoObjects&&"function"==typeof o.geoObjects.remove?o.geoObjects.remove(t):o.remove&&"function"==typeof o.remove&&o.remove(t),C(n))}}const Z={modifyConstructor(t){function e(e,n,o){t.call(this,{geometry:e,properties:n},o)}return e.prototype=t.prototype,e}};P(i(d((t=>o.createElement(T,s({},t,{name:"GeoObject",dangerZone:Z}))),!0,["GeoObject"]))),P(i(d((t=>o.createElement(T,s({},t,{name:"Circle"}))),!0,["Circle"])));var z=P(i(d((t=>o.createElement(T,s({},t,{name:"Placemark"}))),!0,["Placemark"])));P(i(d((t=>o.createElement(T,s({},t,{name:"Polygon"}))),!0,["Polygon"]))),P(i(d((t=>o.createElement(T,s({},t,{name:"Polyline"}))),!0,["Polyline"]))),P(i(d((t=>o.createElement(T,s({},t,{name:"Rectangle"}))),!0,["Rectangle"])))}}]);
//# sourceMappingURL=20.c41753f8.chunk.js.map